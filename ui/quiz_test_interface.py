"""
Giao Di·ªán L√†m B√†i Ki·ªÉm Tra QuizForce AI
Interface chuy√™n nghi·ªáp cho h·ªçc sinh l√†m b√†i ki·ªÉm tra tr·ª±c tuy·∫øn
"""

import streamlit as st
import json
import time
from datetime import datetime
import sys
from pathlib import Path

# Import engine
sys.path.append(str(Path(__file__).parent.parent))
from backend.quiz_test_engine import QuizTestEngine

def render_quiz_test_page():
    """Render trang l√†m b√†i ki·ªÉm tra."""
    # Ch·ªâ set page config khi ch·∫°y standalone
    if __name__ == "__main__":
        st.set_page_config(
            page_title="QuizForce AI - L√†m B√†i Ki·ªÉm Tra",
            page_icon="üìù",
            layout="wide"
        )
    
    # Initialize engine
    if 'quiz_engine' not in st.session_state:
        st.session_state.quiz_engine = QuizTestEngine()
    
    # Header
    st.markdown("""
    <div style='text-align: center; padding: 1rem; background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%); border-radius: 10px; margin-bottom: 2rem;'>
        <h1 style='color: white; margin: 0;'>üìù QuizForce AI - L√†m B√†i Ki·ªÉm Tra</h1>
        <p style='color: #f0f0f0; margin: 0.5rem 0 0 0;'>H·ªá Th·ªëng Ki·ªÉm Tra Tr·ª±c Tuy·∫øn Chuy√™n Nghi·ªáp</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Check if in test session
    if 'current_session_id' in st.session_state and st.session_state.current_session_id:
        render_test_interface()
    else:
        render_test_setup()

def render_test_setup():
    """Render giao di·ªán thi·∫øt l·∫≠p b√†i ki·ªÉm tra."""
    st.markdown("## üéØ Thi·∫øt L·∫≠p B√†i Ki·ªÉm Tra")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Ph·∫ßn nh·∫≠p th√¥ng tin
        st.markdown("### üë®‚Äçüéì Th√¥ng Tin H·ªçc Sinh")
        
        student_name = st.text_input(
            "H·ªç v√† t√™n:",
            placeholder="Nguy·ªÖn VƒÉn A",
            help="Nh·∫≠p h·ªç t√™n ƒë·∫ßy ƒë·ªß c·ªßa h·ªçc sinh"
        )
        
        test_title = st.text_input(
            "T√™n b√†i ki·ªÉm tra:",
            placeholder="Ki·ªÉm tra To√°n h·ªçc - Ch∆∞∆°ng 1",
            help="ƒê·∫∑t t√™n cho b√†i ki·ªÉm tra n√†y"
        )
        
        st.markdown("### üìö T·∫£i C√¢u H·ªèi")
        
        # Tabs cho c√°c c√°ch t·∫£i c√¢u h·ªèi
        source_tabs = st.tabs(["üìÑ Upload File JSON", "üîÑ T·ª´ Quiz ƒê√£ T·∫°o"])
        
        questions_data = None
        
        with source_tabs[0]:
            st.markdown("**Upload file JSON ch·ª©a c√¢u h·ªèi:**")
            uploaded_file = st.file_uploader(
                "Ch·ªçn file JSON:",
                type=['json'],
                help="File JSON ƒë∆∞·ª£c t·∫°o t·ª´ QuizMaster AI"
            )
            
            if uploaded_file:
                try:
                    questions_data = json.load(uploaded_file)
                    st.success(f"‚úÖ ƒê√£ t·∫£i {len(questions_data)} c√¢u h·ªèi t·ª´ file JSON")
                    
                    # Preview
                    with st.expander("üëÄ Xem tr∆∞·ªõc c√¢u h·ªèi"):
                        for i, q in enumerate(questions_data[:3]):
                            st.write(f"**C√¢u {q.get('so_cau', i+1)}:** {q.get('cau_hoi', '')[:100]}...")
                        if len(questions_data) > 3:
                            st.info(f"... v√† {len(questions_data) - 3} c√¢u h·ªèi kh√°c")
                            
                except Exception as e:
                    st.error(f"‚ùå L·ªói ƒë·ªçc file JSON: {str(e)}")
        
        with source_tabs[1]:
            st.markdown("**S·ª≠ d·ª•ng c√¢u h·ªèi t·ª´ quiz ƒë√£ t·∫°o:**")
            
            if 'quiz_results' in st.session_state and st.session_state.quiz_results:
                if st.session_state.quiz_results.get('success') and st.session_state.quiz_results.get('compiled_questions'):
                    questions_data = st.session_state.quiz_results['compiled_questions']
                    st.success(f"‚úÖ S·ª≠ d·ª•ng {len(questions_data)} c√¢u h·ªèi t·ª´ quiz v·ª´a t·∫°o")
                    
                    # Preview
                    with st.expander("üëÄ Xem tr∆∞·ªõc c√¢u h·ªèi"):
                        for i, q in enumerate(questions_data[:3]):
                            st.write(f"**C√¢u {q.get('so_cau', i+1)}:** {q.get('cau_hoi', '')[:100]}...")
                        if len(questions_data) > 3:
                            st.info(f"... v√† {len(questions_data) - 3} c√¢u h·ªèi kh√°c")
                else:
                    st.warning("‚ö†Ô∏è Quiz ch∆∞a ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng. Vui l√≤ng t·∫°o quiz tr∆∞·ªõc.")
            else:
                st.info("‚ÑπÔ∏è Ch∆∞a c√≥ quiz n√†o ƒë∆∞·ª£c t·∫°o. H√£y t·∫°o quiz ·ªü trang ch√≠nh tr∆∞·ªõc.")
    
    with col2:
        # C·∫•u h√¨nh b√†i ki·ªÉm tra
        st.markdown("### ‚öôÔ∏è C·∫•u H√¨nh B√†i Ki·ªÉm Tra")
        
        time_limit = st.selectbox(
            "Th·ªùi gian l√†m b√†i:",
            [15, 30, 45, 60, 90, 120],
            index=3,
            format_func=lambda x: f"{x} ph√∫t",
            help="Ch·ªçn th·ªùi gian l√†m b√†i ph√π h·ª£p"
        )
        
        shuffle_questions = st.checkbox(
            "üîÄ Tr·ªôn th·ª© t·ª± c√¢u h·ªèi",
            value=True,
            help="C√¢u h·ªèi s·∫Ω hi·ªÉn th·ªã ng·∫´u nhi√™n"
        )
        
        shuffle_answers = st.checkbox(
            "üé≤ Tr·ªôn th·ª© t·ª± ƒë√°p √°n",
            value=True,
            help="C√°c l·ª±a ch·ªçn A, B, C, D s·∫Ω ƒë∆∞·ª£c tr·ªôn ng·∫´u nhi√™n"
        )
        
        st.markdown("### ‚ÑπÔ∏è H∆∞·ªõng D·∫´n")
        st.info("""
        **Quy t·∫Øc l√†m b√†i:**
        - ƒê·ªçc k·ªπ ƒë·ªÅ b√†i tr∆∞·ªõc khi ch·ªçn ƒë√°p √°n
        - C√≥ th·ªÉ quay l·∫°i c√¢u ƒë√£ l√†m ƒë·ªÉ s·ª≠a
        - Th·ªùi gian s·∫Ω t·ª± ƒë·ªông d·ª´ng khi h·∫øt gi·ªù
        - Nh·∫•n "Ho√†n th√†nh" ƒë·ªÉ n·ªôp b√†i
        
        **L∆∞u √Ω:**
        - Kh√¥ng ƒë∆∞·ª£c l√†m b√†i c√πng l√∫c nhi·ªÅu tab
        - ƒê·∫£m b·∫£o k·∫øt n·ªëi internet ·ªïn ƒë·ªãnh
        """)
    
    # N√∫t b·∫Øt ƒë·∫ßu
    st.markdown("---")
    
    can_start = (
        student_name and student_name.strip() and
        test_title and test_title.strip() and
        questions_data and len(questions_data) > 0
    )
    
    if not can_start:
        if not student_name:
            st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p h·ªç t√™n h·ªçc sinh")
        elif not test_title:
            st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n b√†i ki·ªÉm tra")
        elif not questions_data:
            st.warning("‚ö†Ô∏è Vui l√≤ng t·∫£i c√¢u h·ªèi t·ª´ file JSON ho·∫∑c quiz ƒë√£ t·∫°o")
    else:
        st.success("‚úÖ ƒê√£ s·∫µn s√†ng b·∫Øt ƒë·∫ßu l√†m b√†i!")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        if st.button(
            "üöÄ B·∫Øt ƒê·∫ßu L√†m B√†i Ki·ªÉm Tra",
            disabled=not can_start,
            use_container_width=True,
            type="primary"
        ):
            if can_start:
                start_new_test(student_name, test_title, questions_data, time_limit, shuffle_questions, shuffle_answers)

def start_new_test(student_name: str, test_title: str, questions_data: list, 
                  time_limit: int, shuffle_questions: bool, shuffle_answers: bool):
    """B·∫Øt ƒë·∫ßu b√†i ki·ªÉm tra m·ªõi."""
    try:
        # Load questions
        engine = st.session_state.quiz_engine
        questions = engine.load_questions_from_json(questions_data)
        
        if not questions:
            st.error("‚ùå Kh√¥ng th·ªÉ t·∫£i c√¢u h·ªèi. Vui l√≤ng ki·ªÉm tra file JSON.")
            return
        
        # Create session
        session_id = engine.create_test_session(
            student_name=student_name,
            test_title=test_title,
            questions=questions,
            time_limit=time_limit,
            shuffle_questions=shuffle_questions,
            shuffle_answers=shuffle_answers
        )
        
        # Save session to streamlit state
        st.session_state.current_session_id = session_id
        
        st.success("üéâ B√†i ki·ªÉm tra ƒë√£ ƒë∆∞·ª£c t·∫°o! ƒêang chuy·ªÉn h∆∞·ªõng...")
        time.sleep(1)
        st.rerun()
        
    except Exception as e:
        st.error(f"‚ùå L·ªói t·∫°o b√†i ki·ªÉm tra: {str(e)}")

def render_test_interface():
    """Render giao di·ªán l√†m b√†i ki·ªÉm tra."""
    session_id = st.session_state.current_session_id
    engine = st.session_state.quiz_engine
    
    # Get current question
    current_q = engine.get_current_question(session_id)
    
    if not current_q:
        # Test finished or error
        render_test_completed()
        return
    
    # Test overview in sidebar
    with st.sidebar:
        render_test_sidebar(session_id)
    
    # Main test interface
    render_question_interface(session_id, current_q)

def render_test_sidebar(session_id: str):
    """Render sidebar th√¥ng tin b√†i ki·ªÉm tra."""
    engine = st.session_state.quiz_engine
    overview = engine.get_test_overview(session_id)
    
    if not overview:
        return
    
    st.markdown("### üìä Th√¥ng Tin B√†i Ki·ªÉm Tra")
    
    # Student info
    st.info(f"""
    **H·ªçc sinh:** {overview['student_name']}
    **B√†i ki·ªÉm tra:** {overview['test_title']}
    """)
    
    # Progress
    st.markdown("### üìà Ti·∫øn ƒê·ªô")
    progress = overview['progress']
    st.progress(progress / 100)
    st.write(f"ƒê√£ l√†m: {overview['answered_questions']}/{overview['total_questions']} c√¢u")
    
    # Time
    st.markdown("### ‚è∞ Th·ªùi Gian")
    time_remaining = overview['time_remaining']
    
    if time_remaining > 0:
        minutes = time_remaining // 60
        seconds = time_remaining % 60
        
        # Warning colors
        if time_remaining <= 300:  # 5 minutes
            st.error(f"‚ö†Ô∏è C√≤n l·∫°i: {minutes:02d}:{seconds:02d}")
        elif time_remaining <= 600:  # 10 minutes
            st.warning(f"‚è±Ô∏è C√≤n l·∫°i: {minutes:02d}:{seconds:02d}")
        else:
            st.success(f"‚è±Ô∏è C√≤n l·∫°i: {minutes:02d}:{seconds:02d}")
    else:
        st.error("‚è∞ H·∫øt th·ªùi gian!")
    
    st.write(f"ƒê√£ l√†m: {overview['time_elapsed']}")
    
    # Question navigator
    st.markdown("### üóÇÔ∏è ƒêi·ªÅu H∆∞·ªõng C√¢u H·ªèi")
    
    # Grid of question numbers
    cols_per_row = 5
    total_questions = overview['total_questions']
    
    for row_start in range(1, total_questions + 1, cols_per_row):
        cols = st.columns(cols_per_row)
        
        for i, col in enumerate(cols):
            q_num = row_start + i
            if q_num <= total_questions:
                # Color coding
                if q_num in [q.so_cau for q in engine.active_sessions[session_id].questions 
                           if q.so_cau in engine.active_sessions[session_id].answers]:
                    button_type = "secondary"  # Answered
                    label = f"‚úÖ{q_num}"
                else:
                    button_type = "primary"  # Not answered
                    label = f"{q_num}"
                
                if col.button(label, key=f"nav_{q_num}", use_container_width=True):
                    engine.goto_question(session_id, q_num)
                    st.rerun()
    
    # Quick actions
    st.markdown("### üéØ H√†nh ƒê·ªông")
    
    if st.button("üìã Xem T·ªïng Quan", use_container_width=True):
        st.session_state.show_overview = True
        st.rerun()
    
    if st.button("üèÅ Ho√†n Th√†nh B√†i Ki·ªÉm Tra", use_container_width=True, type="primary"):
        if st.session_state.get('confirm_finish'):
            result = engine.finish_test(session_id)
            st.session_state.test_result = result
            st.session_state.current_session_id = None
            st.rerun()
        else:
            st.session_state.confirm_finish = True
            st.rerun()
    
    if st.session_state.get('confirm_finish'):
        st.warning("‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën ho√†n th√†nh b√†i ki·ªÉm tra?")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("‚úÖ C√≥", use_container_width=True):
                result = engine.finish_test(session_id)
                st.session_state.test_result = result
                st.session_state.current_session_id = None
                st.session_state.confirm_finish = False
                st.rerun()
        with col2:
            if st.button("‚ùå Kh√¥ng", use_container_width=True):
                st.session_state.confirm_finish = False
                st.rerun()

def render_question_interface(session_id: str, current_q: dict):
    """Render giao di·ªán c√¢u h·ªèi hi·ªán t·∫°i."""
    engine = st.session_state.quiz_engine
    question_data = current_q['question_data']
    
    # Question header
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col1:
        st.markdown(f"### C√¢u {current_q['question_number']}/{current_q['total_questions']}")
    
    with col2:
        # Time remaining (auto-refresh)
        time_container = st.empty()
        time_remaining = current_q['time_remaining']
        if time_remaining > 0:
            minutes = time_remaining // 60
            seconds = time_remaining % 60
            time_container.markdown(f"‚è±Ô∏è **Th·ªùi gian c√≤n l·∫°i: {minutes:02d}:{seconds:02d}**")
        else:
            time_container.error("‚è∞ **H·∫øt th·ªùi gian!**")
    
    with col3:
        progress = current_q['progress']
        st.markdown(f"üìä **Ti·∫øn ƒë·ªô: {progress:.1f}%**")
    
    st.markdown("---")
    
    # Question content
    st.markdown("### üìù C√¢u H·ªèi")
    
    # Display question with nice formatting
    question_text = question_data['cau_hoi']
    st.markdown(f"""
    <div style='background: #f8f9fa; padding: 1.5rem; border-radius: 10px; border-left: 4px solid #007bff; margin-bottom: 1rem;'>
        <h4 style='margin: 0; color: #495057;'>{question_text}</h4>
    </div>
    """, unsafe_allow_html=True)
    
    # Answer choices
    st.markdown("### üî§ L·ª±a Ch·ªçn ƒê√°p √Ån")
    
    choices = question_data['lua_chon']
    current_answer = current_q['current_answer']
    
    # Display choices as radio buttons
    answer_options = []
    for choice, content in choices.items():
        answer_options.append(f"{choice}. {content}")
    
    # Find current selection index
    current_index = 0
    if current_answer:
        for i, choice in enumerate(choices.keys()):
            if choice == current_answer:
                current_index = i
                break
    
    selected_answer = st.radio(
        "Ch·ªçn ƒë√°p √°n:",
        answer_options,
        index=current_index if current_answer else None,
        key=f"answer_{current_q['question_number']}"
    )
    
    # Extract answer letter
    if selected_answer:
        selected_letter = selected_answer.split('.')[0]
        # Submit answer
        engine.submit_answer(session_id, selected_letter)
    
    # Question metadata
    col1, col2 = st.columns(2)
    with col1:
        do_kho = question_data.get('do_kho', 'trung_binh')
        difficulty_color = {
            'de': 'üü¢',
            'trung_binh': 'üü°', 
            'kho': 'üî¥'
        }.get(do_kho, 'üü°')
        st.caption(f"{difficulty_color} ƒê·ªô kh√≥: {do_kho}")
    
    with col2:
        mon_hoc = question_data.get('mon_hoc', 'auto_detect')
        st.caption(f"üìö M√¥n h·ªçc: {mon_hoc}")
    
    # Navigation buttons
    st.markdown("---")
    col1, col2, col3, col4 = st.columns([1, 1, 1, 1])
    
    with col1:
        if st.button("‚¨ÖÔ∏è C√¢u Tr∆∞·ªõc", disabled=current_q['question_number'] == 1):
            engine.previous_question(session_id)
            st.rerun()
    
    with col2:
        if st.button("üìã T·ªïng Quan"):
            st.session_state.show_overview = True
            st.rerun()
    
    with col3:
        if st.button("üîÑ L√†m M·ªõi"):
            st.rerun()
    
    with col4:
        if current_q['question_number'] < current_q['total_questions']:
            if st.button("‚û°Ô∏è C√¢u Ti·∫øp"):
                engine.next_question(session_id)
                st.rerun()
        else:
            if st.button("üèÅ Ho√†n Th√†nh", type="primary"):
                st.session_state.confirm_finish = True
                st.rerun()
    
    # Auto-refresh for timer
    if time_remaining > 0:
        time.sleep(1)
        st.rerun()

def render_test_completed():
    """Render k·∫øt qu·∫£ b√†i ki·ªÉm tra."""
    if 'test_result' not in st.session_state:
        st.error("‚ùå Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ b√†i ki·ªÉm tra")
        if st.button("üè† V·ªÅ Trang Ch·ªß"):
            st.session_state.current_session_id = None
            st.rerun()
        return
    
    result = st.session_state.test_result
    
    # Header
    st.markdown("## üéâ Ho√†n Th√†nh B√†i Ki·ªÉm Tra!")
    
    # Overall results
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üìù T·ªïng S·ªë C√¢u", result.total_questions)
    
    with col2:
        st.metric("‚úÖ C√¢u ƒê√∫ng", result.correct_answers)
    
    with col3:
        st.metric("‚ùå C√¢u Sai", result.wrong_answers)
    
    with col4:
        st.metric("üéØ ƒêi·ªÉm S·ªë", f"{result.score}/10")
    
    # Score visualization
    percentage = result.percentage
    if percentage >= 80:
        score_color = "success"
        score_emoji = "üèÜ"
        score_text = "Xu·∫•t s·∫Øc!"
    elif percentage >= 70:
        score_color = "info"
        score_emoji = "üéñÔ∏è"
        score_text = "Kh√° t·ªët!"
    elif percentage >= 50:
        score_color = "warning"
        score_emoji = "üìà"
        score_text = "Trung b√¨nh"
    else:
        score_color = "error"
        score_emoji = "üìö"
        score_text = "C·∫ßn c·ªë g·∫Øng h∆°n"
    
    st.markdown(f"""
    <div style='text-align: center; padding: 2rem; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); border-radius: 15px; margin: 2rem 0;'>
        <h1 style='color: white; margin: 0; font-size: 3rem;'>{score_emoji}</h1>
        <h2 style='color: white; margin: 0.5rem 0;'>{result.percentage:.1f}% - {score_text}</h2>
        <p style='color: #f0f0f0; margin: 0;'>Th·ªùi gian l√†m b√†i: {result.time_taken}</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Detailed results
    st.markdown("### üìä Chi Ti·∫øt K·∫øt Qu·∫£")
    
    # Filter options
    col1, col2 = st.columns(2)
    with col1:
        show_filter = st.selectbox(
            "Hi·ªÉn th·ªã:",
            ["T·∫•t c·∫£", "Ch·ªâ c√¢u ƒë√∫ng", "Ch·ªâ c√¢u sai"],
            key="result_filter"
        )
    
    with col2:
        sort_by = st.selectbox(
            "S·∫Øp x·∫øp theo:",
            ["S·ªë c√¢u", "K·∫øt qu·∫£", "ƒê·ªô kh√≥"],
            key="result_sort"
        )
    
    # Filter and sort results
    detailed = result.detailed_results
    
    if show_filter == "Ch·ªâ c√¢u ƒë√∫ng":
        detailed = [r for r in detailed if r['ket_qua'] == 'ƒê√∫ng']
    elif show_filter == "Ch·ªâ c√¢u sai":
        detailed = [r for r in detailed if r['ket_qua'] == 'Sai']
    
    if sort_by == "K·∫øt qu·∫£":
        detailed = sorted(detailed, key=lambda x: x['ket_qua'])
    elif sort_by == "ƒê·ªô kh√≥":
        detailed = sorted(detailed, key=lambda x: x['do_kho'])
    
    # Display results
    for i, item in enumerate(detailed):
        with st.expander(f"C√¢u {item['so_cau']}: {item['ket_qua']} {'‚úÖ' if item['ket_qua'] == 'ƒê√∫ng' else '‚ùå'}"):
            st.markdown(f"**C√¢u h·ªèi:** {item['cau_hoi']}")
            
            # Show choices
            for choice, content in item['lua_chon'].items():
                if choice == item['dap_an_dung']:
                    st.success(f"‚úÖ **{choice}.** {content} *(ƒê√°p √°n ƒë√∫ng)*")
                elif choice == item['dap_an_chon']:
                    if item['ket_qua'] == 'Sai':
                        st.error(f"‚ùå **{choice}.** {content} *(B·∫°n ƒë√£ ch·ªçn)*")
                    else:
                        st.success(f"‚úÖ **{choice}.** {content} *(B·∫°n ƒë√£ ch·ªçn)*")
                else:
                    st.write(f"**{choice}.** {content}")
            
            if item['dap_an_chon'] == "Kh√¥ng tr·∫£ l·ªùi":
                st.warning("‚ö†Ô∏è B·∫°n ch∆∞a tr·∫£ l·ªùi c√¢u n√†y")
            
            st.caption(f"ƒê·ªô kh√≥: {item['do_kho']}")
    
    # Actions
    st.markdown("---")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üè† V·ªÅ Trang Ch·ªß", use_container_width=True):
            # Clear session
            st.session_state.current_session_id = None
            st.session_state.test_result = None
            st.rerun()
    
    with col2:
        # Export results as JSON
        result_json = {
            "student_name": result.student_name,
            "test_title": result.test_title,
            "score": result.score,
            "percentage": result.percentage,
            "time_taken": result.time_taken,
            "finish_time": result.finish_time.isoformat(),
            "detailed_results": result.detailed_results
        }
        
        st.download_button(
            "üíæ T·∫£i K·∫øt Qu·∫£ JSON",
            data=json.dumps(result_json, ensure_ascii=False, indent=2),
            file_name=f"ket_qua_{result.student_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            mime="application/json",
            use_container_width=True
        )
    
    with col3:
        if st.button("üîÑ L√†m B√†i M·ªõi", use_container_width=True, type="primary"):
            # Clear session but keep engine
            st.session_state.current_session_id = None
            st.session_state.test_result = None
            st.rerun()

if __name__ == "__main__":
    render_quiz_test_page()
